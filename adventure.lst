ca65 V2.18 - N/A
Main file   : adventure.s
Current file: adventure.s

000000r 1               EXIT  = $1c4f
000000r 1               OUTCH = $1ea0
000000r 1               GETCH = $1e5a
000000r 1               CURRENT_DIRECTORY_NAME = $1000                            ; 12 bytes
000000r 1               INPUT_BUFFER = $100D                                      ; 8 bytes
000000r 1               
000000r 1               
000000r 1               .org $a000
00A000  1  20 D1 A4       jsr newline
00A003  1  20 12 A0       jsr initiallize_fat16
00A006  1  20 21 A0       jsr read_master_boot_record
00A009  1  20 8D A0       jsr read_fat_boot_record
00A00C  1  20 AA A1       jsr read_file_allocation_table
00A00F  1  20 4F 1C       jsr EXIT
00A012  1               
00A012  1               
00A012  1               
00A012  1               
00A012  1               
00A012  1               
00A012  1               
00A012  1               
00A012  1               
00A012  1               
00A012  1               
00A012  1               
00A012  1               
00A012  1               
00A012  1               
00A012  1               
00A012  1               
00A012  1               
00A012  1               
00A012  1               
00A012  1               
00A012  1               
00A012  1               
00A012  1               
00A012  1               
00A012  1               
00A012  1               
00A012  1               
00A012  1               
00A012  1               
00A012  1               
00A012  1               
00A012  1               
00A012  1               
00A012  1               
00A012  1               
00A012  1               
00A012  1               
00A012  1               
00A012  1               
00A012  1               
00A012  1               
00A012  1               
00A012  1               
00A012  1               ; display_welcome_message:
00A012  1               ;   lda #'1'
00A012  1               ;   jsr print_char
00A012  1               ;   jsr fat32_openroot
00A012  1               ;   lda #'2'
00A012  1               ;   jsr print_char
00A012  1               ;   ldx #<messagesdirname
00A012  1               ;   ldy #>messagesdirname
00A012  1               ;   jsr finddirent
00A012  1               ;   lda #'3'
00A012  1               ;   jsr print_char
00A012  1               ;   ldx #<instructions_prompt
00A012  1               ;   ldy #>instructions_prompt
00A012  1               ;   ; jsr load_file
00A012  1               ;   jsr print_file
00A012  1               ;   jsr get_input
00A012  1               ; ; ; TODO Y, N, YES, NO
00A012  1               ; ;   ldx #<instructions
00A012  1               ; ;   ldy #>instructions
00A012  1               ; ;   jsr load_file
00A012  1               ; ;   jsr print_file
00A012  1               
00A012  1               ; _initlocation:
00A012  1               ;   ldx #0
00A012  1               ; _initlocationloop:
00A012  1               ;   lda subdirname,x
00A012  1               ;   sta CURRENT_DIRECTORY_NAME,x
00A012  1               ;   inx
00A012  1               ;   cpx #12
00A012  1               ;   bne _initlocationloop
00A012  1               ; _initlocationdone:
00A012  1               ;   jsr newline
00A012  1               
00A012  1               ; load_current_location:
00A012  1               ;   jsr open_location_directory
00A012  1               ;   ldx #<location
00A012  1               ;   ldy #>location
00A012  1               ; ;  jsr load_file
00A012  1               ;   jsr print_file
00A012  1               
00A012  1               ;   jsr get_input
00A012  1               ;   jsr newline
00A012  1               
00A012  1               ;   jsr open_location_directory
00A012  1               ;   ldx #<traveltable
00A012  1               ;   ldy #>traveltable
00A012  1               ; ;  jsr load_file
00A012  1               
00A012  1               ;   ldx #255
00A012  1               ;   ldy #255
00A012  1               ; tt_loop:
00A012  1               ;   inx
00A012  1               ;   iny
00A012  1               ;   lda INPUT_BUFFER,y
00A012  1               ;   cmp #$20
00A012  1               ;   beq tt_loop_space
00A012  1               ;   cmp buffer,x
00A012  1               ;   bne tt_loop_next_line
00A012  1               ;   jmp tt_loop
00A012  1               ; tt_loop_space:
00A012  1               ;   lda buffer,x
00A012  1               ;   cmp #$20
00A012  1               ;   beq tt_loop_match
00A012  1               ;   jmp tt_loop
00A012  1               ; tt_loop_next_line:
00A012  1               ;   ldy #0
00A012  1               ;   lda buffer,x
00A012  1               ;   inx
00A012  1               ;   cmp #$0A                                 ; advance to the next entry
00A012  1               ;   beq tt_loop
00A012  1               ;   jmp tt_loop_next_line
00A012  1               ; tt_loop_match:
00A012  1               ;   inx
00A012  1               ;   ldy #0
00A012  1               ; tt_loop_update_location:
00A012  1               ;   lda buffer,x
00A012  1               ;   cmp #$0D                                 ; done update location
00A012  1               ;   beq tt_loop_end
00A012  1               ;   sta CURRENT_DIRECTORY_NAME,y
00A012  1               ;   inx
00A012  1               ;   iny
00A012  1               ;   jmp tt_loop_update_location
00A012  1               ; tt_loop_end:
00A012  1               ;   jmp load_current_location
00A012  1               
00A012  1               ; _exit:
00A012  1               ;   jsr EXIT
00A012  1               
00A012  1               ; get_input:
00A012  1               ;   jsr newline
00A012  1               ;   lda #'>'
00A012  1               ;   jsr print_char
00A012  1               ;   lda #' '
00A012  1               ;   jsr print_char
00A012  1               
00A012  1               ;   ldx #0
00A012  1               ; getcharacter:
00A012  1               ;   jsr get_char
00A012  1               ;   sta INPUT_BUFFER,x
00A012  1               ;   inx
00A012  1               ;   cmp #$0D                   ; Enter key
00A012  1               ;   bne getcharacter           ; Keep getting characters until we see enter
00A012  1               ;   dex
00A012  1               ;   lda #$20                   ; Replace CR with space
00A012  1               ;   sta INPUT_BUFFER,x
00A012  1               ;   jsr newline
00A012  1               ;   rts
00A012  1               
00A012  1               ; ; directory names
00A012  1               ; subdirname:
00A012  1               ;   .asciiz "1          "
00A012  1               
00A012  1               ; messagesdirname:
00A012  1               ;   .asciiz "MESSAGES   "
00A012  1               
00A012  1               ; ; generic text filenames
00A012  1               ; location:
00A012  1               ;   .asciiz "LOCATIONTXT"
00A012  1               
00A012  1               ; short_description:
00A012  1               ;   .asciiz "SHORTDESTXT"
00A012  1               
00A012  1               ; traveltable:
00A012  1               ;   .asciiz "TVLTABLETXT"
00A012  1               
00A012  1               ; ; message filenames
00A012  1               ; instructions:
00A012  1               ;   .asciiz "1       TXT"
00A012  1               
00A012  1               ; instructions_prompt:
00A012  1               ;   .asciiz "65      TXT"
00A012  1               
00A012  1               
00A012  1               
00A012  1               ; .include "file_operations.s"
00A012  1               .include "libfat16.s"
00A012  2               ; Boot sector    2048 = 0x100000/512
00A012  2               ; FAT Tables:
00A012  2               ;     2048 + 0x0400 (0x04 sectors)
00A012  2               ; Primary FAT    2052 = 0x100800/512
00A012  2               ; Secondary FAT  2152 = 0x10D000/512
00A012  2               ; Root Directory:
00A012  2               ;     2048 + 0x0400 + 0x64 (100) x 2
00A012  2               ;     size: max entries (32) x 512
00A012  2               ; Root directory 2252
00A012  2               ; Data Area:
00A012  2               ;     2048 + 0x0400 + 0x64 (100) x 2 + ((512 * 32) / 512)
00A012  2               ; Data area      2284
00A012  2               CURRENT_BUFFER_LOCATION = $00                             ; 2 bytes
00A012  2               SECTOR_INDEX = $02                                        ; 4 bytes
00A012  2               FIRST_PARTITION_STATE = $06                               ; 1 byte
00A012  2               FIRST_PARTITION_BEGINNING_HEAD = $07                      ; 1 byte
00A012  2               FIRST_PARTITION_BEGINNING_SECTOR = $08                    ; 2 bytes
00A012  2               FIRST_PARTITION_TYPE = $0A                                ; 1 byte
00A012  2               FIRST_PARTITION_ENDING_HEAD = $0B                         ; 1 byte
00A012  2               FIRST_PARTITION_ENDING_SECTOR = $0C                       ; 2 bytes
00A012  2               FIRST_PARTITION_SECTOR_OFFSET = $0D                       ; 4 bytes
00A012  2               FIRST_PARTITION_TOTAL_SECTORS = $11                       ; 4 bytes
00A012  2               FAT16_BYTES_PER_SECTOR = $15                              ; 2 bytes
00A012  2               FAT16_BYTES_SECTORS_PER_CLUSTER = $17                     ; 1 byte
00A012  2               FAT16_RESERVED_SECTORS = $18                              ; 2 bytes
00A012  2               FAT16_FAT_COPIES = $1A                                    ; 1 byte
00A012  2               FAT16_MAXIMUM_ROOT_DIRECTORY_ENTRIES = $1B                ; 2 bytes
00A012  2               FAT16_NUMBER_OF_SECTORS_LESS_THAN_32M = $1D               ; 2 bytes
00A012  2               FAT16_MEDIA_DESCRIPTOR = $1F                              ; 1 byte
00A012  2               FAT16_SECTORS_PER_FAT = $20                               ; 2 bytes
00A012  2               FAT16_SECTORS_PER_TRACK = $22                             ; 2 bytes
00A012  2               FAT16_NUBMER_OF_HEADS = $24                               ; 2 bytes
00A012  2               FAT16_NUBMER_OF_HIDDEN_SECTORS = $26                      ; 4 bytes
00A012  2               FAT16_NUBMER_OF_SECTORS = $2A                             ; 4 bytes
00A012  2               FAT16_LOGICAL_DRIVE_NUMBER_OF_PARTITION = $2E             ; 2 bytes
00A012  2               FAT16_EXTENDED_SIGNATURE = $30                            ; 1 byte
00A012  2               FAT16_SERIAL_NUMBER = $31                                 ; 4 bytes
00A012  2               FAT16_VOLUME_NAME = $35                                   ; 11 bytes
00A012  2               FAT16_FAT_NAME = $40                                      ; 8 bytes
00A012  2               ; SD card constants
00A012  2               zp_sd_address = $48                                       ; 2 bytes
00A012  2               zp_sd_currentsector = $4A                                 ; 4 bytes
00A012  2               
00A012  2               BUFFER = $2000
00A012  2               
00A012  2               
00A012  2               initiallize_fat16:
00A012  2                 ; Initialise SD card
00A012  2  20 DD A2       jsr via_init
00A015  2  20 E8 A2       jsr sd_init
00A018  2                 ; Target buffer
00A018  2  A9 00          lda #<BUFFER
00A01A  2  85 48          sta zp_sd_address
00A01C  2  A9 20          lda #>BUFFER
00A01E  2  85 49          sta zp_sd_address+1
00A020  2  60             rts
00A021  2               
00A021  2               read_master_boot_record:
00A021  2                 ; Load a pointer to the data buffer
00A021  2  A9 00          lda #<BUFFER
00A023  2  85 00          sta CURRENT_BUFFER_LOCATION
00A025  2  A9 20          lda #>BUFFER
00A027  2  85 01          sta CURRENT_BUFFER_LOCATION+1
00A029  2                 ; Set current sector
00A029  2  A9 00          lda #0
00A02B  2  85 4A          sta zp_sd_currentsector
00A02D  2  85 4B          sta zp_sd_currentsector+1
00A02F  2  85 4C          sta zp_sd_currentsector+2
00A031  2  85 4D          sta zp_sd_currentsector+3
00A033  2                 ; Read MBR table
00A033  2  20 F1 A3       jsr sd_readsector
00A036  2                 ; Skip the first 446 bytes containing Executable Code
00A036  2  A0 BE          ldy #190
00A038  2  E6 01          inc CURRENT_BUFFER_LOCATION+1
00A03A  2                 ; 1st Partition Entry
00A03A  2                 ; Current State of Partition (00h=Inactive, 80h=Active)
00A03A  2  B1 00          lda (CURRENT_BUFFER_LOCATION),y
00A03C  2  85 06          sta FIRST_PARTITION_STATE
00A03E  2  C8             iny
00A03F  2                 ; Beginning of Partition - Head
00A03F  2  B1 00          lda (CURRENT_BUFFER_LOCATION),y
00A041  2  85 07          sta FIRST_PARTITION_BEGINNING_HEAD
00A043  2  C8             iny
00A044  2                 ; Beginning of Partition - Cylinder/Sector TODO bitwise operations
00A044  2  B1 00          lda (CURRENT_BUFFER_LOCATION),y
00A046  2  85 08          sta FIRST_PARTITION_BEGINNING_SECTOR
00A048  2  C8             iny
00A049  2  B1 00          lda (CURRENT_BUFFER_LOCATION),y
00A04B  2  85 09          sta FIRST_PARTITION_BEGINNING_SECTOR+1
00A04D  2  C8             iny
00A04E  2                 ; Partition type
00A04E  2                 ; 04 FAT16 <32M
00A04E  2                 ; 06 FAT16 (currently the only tested partitioin type)
00A04E  2                 ; 14 Hidden FAT16 <32
00A04E  2                 ; 16 Hidden FAT16
00A04E  2  B1 00          lda (CURRENT_BUFFER_LOCATION),y
00A050  2  85 0A          sta FIRST_PARTITION_TYPE
00A052  2  C8             iny
00A053  2                 ; End of Partition - Head
00A053  2  B1 00          lda (CURRENT_BUFFER_LOCATION),y
00A055  2  85 0B          sta FIRST_PARTITION_ENDING_HEAD
00A057  2  C8             iny
00A058  2                 ; End of Partition - Cyl/Sec TODO bitwise math
00A058  2  B1 00          lda (CURRENT_BUFFER_LOCATION),y
00A05A  2  85 0C          sta FIRST_PARTITION_ENDING_SECTOR
00A05C  2  C8             iny
00A05D  2  B1 00          lda (CURRENT_BUFFER_LOCATION),y
00A05F  2  85 0D          sta FIRST_PARTITION_ENDING_SECTOR+1
00A061  2  C8             iny
00A062  2                 ; Number of Sectors Between the MBR and the First Sector in the Partition (reverse bits gives you 2048)
00A062  2  B1 00          lda (CURRENT_BUFFER_LOCATION),y
00A064  2  85 0D          sta FIRST_PARTITION_SECTOR_OFFSET
00A066  2  C8             iny
00A067  2  B1 00          lda (CURRENT_BUFFER_LOCATION),y
00A069  2  85 0E          sta FIRST_PARTITION_SECTOR_OFFSET+1
00A06B  2  C8             iny
00A06C  2  B1 00          lda (CURRENT_BUFFER_LOCATION),y
00A06E  2  85 0F          sta FIRST_PARTITION_SECTOR_OFFSET+2
00A070  2  C8             iny
00A071  2  B1 00          lda (CURRENT_BUFFER_LOCATION),y
00A073  2  85 10          sta FIRST_PARTITION_SECTOR_OFFSET+3
00A075  2  C8             iny
00A076  2  20 D1 A4       jsr newline
00A079  2                 ; Number of Sectors in the Partition
00A079  2  B1 00          lda (CURRENT_BUFFER_LOCATION),y
00A07B  2  85 11          sta FIRST_PARTITION_TOTAL_SECTORS
00A07D  2  C8             iny
00A07E  2  B1 00          lda (CURRENT_BUFFER_LOCATION),y
00A080  2  85 12          sta FIRST_PARTITION_TOTAL_SECTORS+1
00A082  2  C8             iny
00A083  2  B1 00          lda (CURRENT_BUFFER_LOCATION),y
00A085  2  85 13          sta FIRST_PARTITION_TOTAL_SECTORS+2
00A087  2  C8             iny
00A088  2  B1 00          lda (CURRENT_BUFFER_LOCATION),y
00A08A  2  85 14          sta FIRST_PARTITION_TOTAL_SECTORS+3
00A08C  2  60             rts
00A08D  2               
00A08D  2               read_fat_boot_record:
00A08D  2                 ; Load a pointer to the data buffer
00A08D  2  A9 00          lda #<BUFFER
00A08F  2  85 00          sta CURRENT_BUFFER_LOCATION
00A091  2  A9 20          lda #>BUFFER
00A093  2  85 01          sta CURRENT_BUFFER_LOCATION+1
00A095  2                 ; Read FAT boot record
00A095  2                 ; 2048 00000000 00000000 00001000 00000000 / 0x00 0x08 0x00 0x00 - little indian
00A095  2                 ; Set current sector
00A095  2  A5 0D          lda FIRST_PARTITION_SECTOR_OFFSET
00A097  2  85 4A          sta zp_sd_currentsector
00A099  2  A5 0E          lda FIRST_PARTITION_SECTOR_OFFSET+1
00A09B  2  85 4B          sta zp_sd_currentsector+1
00A09D  2  A5 0F          lda FIRST_PARTITION_SECTOR_OFFSET+2
00A09F  2  85 4C          sta zp_sd_currentsector+2
00A0A1  2  A5 10          lda FIRST_PARTITION_SECTOR_OFFSET+3
00A0A3  2  85 4D          sta zp_sd_currentsector+3
00A0A5  2  20 F1 A3       jsr sd_readsector
00A0A8  2                 ; FAT bytes per sector
00A0A8  2  A0 0B          ldy #11
00A0AA  2  B1 00          lda (CURRENT_BUFFER_LOCATION),y
00A0AC  2  85 15          sta FAT16_BYTES_PER_SECTOR
00A0AE  2  C8             iny
00A0AF  2  B1 00          lda (CURRENT_BUFFER_LOCATION),y
00A0B1  2  85 16          sta FAT16_BYTES_PER_SECTOR+1
00A0B3  2  C8             iny
00A0B4  2                 ; FAT bytes per cluster
00A0B4  2  B1 00          lda (CURRENT_BUFFER_LOCATION),y
00A0B6  2  85 17          sta FAT16_BYTES_SECTORS_PER_CLUSTER
00A0B8  2  C8             iny
00A0B9  2                 ; FAT reserved sectors
00A0B9  2  B1 00          lda (CURRENT_BUFFER_LOCATION),y
00A0BB  2  85 18          sta FAT16_RESERVED_SECTORS
00A0BD  2  C8             iny
00A0BE  2  B1 00          lda (CURRENT_BUFFER_LOCATION),y
00A0C0  2  85 19          sta FAT16_RESERVED_SECTORS+1
00A0C2  2  C8             iny
00A0C3  2                 ; FAT copies
00A0C3  2  B1 00          lda (CURRENT_BUFFER_LOCATION),y
00A0C5  2  85 1A          sta FAT16_FAT_COPIES
00A0C7  2  C8             iny
00A0C8  2                 ; Maximum Root Directory Entries
00A0C8  2  B1 00          lda (CURRENT_BUFFER_LOCATION),y
00A0CA  2  85 1B          sta FAT16_MAXIMUM_ROOT_DIRECTORY_ENTRIES
00A0CC  2  C8             iny
00A0CD  2  B1 00          lda (CURRENT_BUFFER_LOCATION),y
00A0CF  2  85 1C          sta FAT16_MAXIMUM_ROOT_DIRECTORY_ENTRIES+1
00A0D1  2  C8             iny
00A0D2  2                 ; Number of Sectors in Partition Smaller than 32MB
00A0D2  2  B1 00          lda (CURRENT_BUFFER_LOCATION),y
00A0D4  2  85 1D          sta FAT16_NUMBER_OF_SECTORS_LESS_THAN_32M
00A0D6  2  C8             iny
00A0D7  2  B1 00          lda (CURRENT_BUFFER_LOCATION),y
00A0D9  2  85 1E          sta FAT16_NUMBER_OF_SECTORS_LESS_THAN_32M+1
00A0DB  2  C8             iny
00A0DC  2                 ; Media Descriptor (F8h for Hard Disks)
00A0DC  2  B1 00          lda (CURRENT_BUFFER_LOCATION),y
00A0DE  2  85 1F          sta FAT16_MEDIA_DESCRIPTOR
00A0E0  2  C8             iny
00A0E1  2                 ; Sectors per fat
00A0E1  2  B1 00          lda (CURRENT_BUFFER_LOCATION),y
00A0E3  2  85 20          sta FAT16_SECTORS_PER_FAT
00A0E5  2  C8             iny
00A0E6  2  B1 00          lda (CURRENT_BUFFER_LOCATION),y
00A0E8  2  85 21          sta FAT16_SECTORS_PER_FAT+1
00A0EA  2  C8             iny
00A0EB  2                 ; Sectors Per Track
00A0EB  2  B1 00          lda (CURRENT_BUFFER_LOCATION),y
00A0ED  2  85 22          sta FAT16_SECTORS_PER_TRACK
00A0EF  2  C8             iny
00A0F0  2  B1 00          lda (CURRENT_BUFFER_LOCATION),y
00A0F2  2  85 23          sta FAT16_SECTORS_PER_TRACK+1
00A0F4  2  C8             iny
00A0F5  2                 ; Number of Heads
00A0F5  2  B1 00          lda (CURRENT_BUFFER_LOCATION),y
00A0F7  2  85 24          sta FAT16_NUBMER_OF_HEADS
00A0F9  2  C8             iny
00A0FA  2  B1 00          lda (CURRENT_BUFFER_LOCATION),y
00A0FC  2  85 25          sta FAT16_NUBMER_OF_HEADS+1
00A0FE  2  C8             iny
00A0FF  2                 ; Number of Hidden Sectors in Partition
00A0FF  2  B1 00          lda (CURRENT_BUFFER_LOCATION),y
00A101  2  85 26          sta FAT16_NUBMER_OF_HIDDEN_SECTORS
00A103  2  C8             iny
00A104  2  B1 00          lda (CURRENT_BUFFER_LOCATION),y
00A106  2  85 27          sta FAT16_NUBMER_OF_HIDDEN_SECTORS+1
00A108  2  C8             iny
00A109  2  B1 00          lda (CURRENT_BUFFER_LOCATION),y
00A10B  2  85 28          sta FAT16_NUBMER_OF_HIDDEN_SECTORS+2
00A10D  2  C8             iny
00A10E  2  B1 00          lda (CURRENT_BUFFER_LOCATION),y
00A110  2  85 29          sta FAT16_NUBMER_OF_HIDDEN_SECTORS+3
00A112  2  C8             iny
00A113  2                 ; Number of Sectors in Partition
00A113  2  B1 00          lda (CURRENT_BUFFER_LOCATION),y
00A115  2  85 2A          sta FAT16_NUBMER_OF_SECTORS
00A117  2  C8             iny
00A118  2  B1 00          lda (CURRENT_BUFFER_LOCATION),y
00A11A  2  85 2B          sta FAT16_NUBMER_OF_SECTORS+1
00A11C  2  C8             iny
00A11D  2  B1 00          lda (CURRENT_BUFFER_LOCATION),y
00A11F  2  85 2C          sta FAT16_NUBMER_OF_SECTORS+2
00A121  2  C8             iny
00A122  2  B1 00          lda (CURRENT_BUFFER_LOCATION),y
00A124  2  85 2D          sta FAT16_NUBMER_OF_SECTORS+3
00A126  2  C8             iny
00A127  2                 ; Logical Drive Number of Partition
00A127  2  B1 00          lda (CURRENT_BUFFER_LOCATION),y
00A129  2  85 2E          sta FAT16_LOGICAL_DRIVE_NUMBER_OF_PARTITION
00A12B  2  C8             iny
00A12C  2  B1 00          lda (CURRENT_BUFFER_LOCATION),y
00A12E  2  85 2F          sta FAT16_LOGICAL_DRIVE_NUMBER_OF_PARTITION+1
00A130  2  C8             iny
00A131  2                 ; Extended Signature (29h)
00A131  2  B1 00          lda (CURRENT_BUFFER_LOCATION),y
00A133  2  85 30          sta FAT16_EXTENDED_SIGNATURE
00A135  2  C8             iny
00A136  2                 ; Serial Number of Partition
00A136  2  B1 00          lda (CURRENT_BUFFER_LOCATION),y
00A138  2  85 31          sta FAT16_SERIAL_NUMBER
00A13A  2  C8             iny
00A13B  2  B1 00          lda (CURRENT_BUFFER_LOCATION),y
00A13D  2  85 32          sta FAT16_SERIAL_NUMBER+1
00A13F  2  C8             iny
00A140  2  B1 00          lda (CURRENT_BUFFER_LOCATION),y
00A142  2  85 33          sta FAT16_SERIAL_NUMBER+2
00A144  2  C8             iny
00A145  2  B1 00          lda (CURRENT_BUFFER_LOCATION),y
00A147  2  85 34          sta FAT16_SERIAL_NUMBER+3
00A149  2  C8             iny
00A14A  2                 ; Volume Name
00A14A  2  B1 00          lda (CURRENT_BUFFER_LOCATION),y
00A14C  2  85 35          sta FAT16_VOLUME_NAME
00A14E  2  C8             iny
00A14F  2  B1 00          lda (CURRENT_BUFFER_LOCATION),y
00A151  2  85 36          sta FAT16_VOLUME_NAME+1
00A153  2  C8             iny
00A154  2  B1 00          lda (CURRENT_BUFFER_LOCATION),y
00A156  2  85 37          sta FAT16_VOLUME_NAME+2
00A158  2  C8             iny
00A159  2  B1 00          lda (CURRENT_BUFFER_LOCATION),y
00A15B  2  85 38          sta FAT16_VOLUME_NAME+3
00A15D  2  C8             iny
00A15E  2  B1 00          lda (CURRENT_BUFFER_LOCATION),y
00A160  2  85 39          sta FAT16_VOLUME_NAME+4
00A162  2  C8             iny
00A163  2  B1 00          lda (CURRENT_BUFFER_LOCATION),y
00A165  2  85 3A          sta FAT16_VOLUME_NAME+5
00A167  2  C8             iny
00A168  2  B1 00          lda (CURRENT_BUFFER_LOCATION),y
00A16A  2  85 3B          sta FAT16_VOLUME_NAME+6
00A16C  2  C8             iny
00A16D  2  B1 00          lda (CURRENT_BUFFER_LOCATION),y
00A16F  2  85 3C          sta FAT16_VOLUME_NAME+7
00A171  2  C8             iny
00A172  2  B1 00          lda (CURRENT_BUFFER_LOCATION),y
00A174  2  85 3D          sta FAT16_VOLUME_NAME+8
00A176  2  C8             iny
00A177  2  B1 00          lda (CURRENT_BUFFER_LOCATION),y
00A179  2  85 3E          sta FAT16_VOLUME_NAME+9
00A17B  2  C8             iny
00A17C  2  B1 00          lda (CURRENT_BUFFER_LOCATION),y
00A17E  2  85 3F          sta FAT16_VOLUME_NAME+10
00A180  2  C8             iny
00A181  2                 ; FAT Name (FAT16)
00A181  2  B1 00          lda (CURRENT_BUFFER_LOCATION),y
00A183  2  85 40          sta FAT16_FAT_NAME
00A185  2  C8             iny
00A186  2  B1 00          lda (CURRENT_BUFFER_LOCATION),y
00A188  2  85 41          sta FAT16_FAT_NAME+1
00A18A  2  C8             iny
00A18B  2  B1 00          lda (CURRENT_BUFFER_LOCATION),y
00A18D  2  85 42          sta FAT16_FAT_NAME+2
00A18F  2  C8             iny
00A190  2  B1 00          lda (CURRENT_BUFFER_LOCATION),y
00A192  2  85 43          sta FAT16_FAT_NAME+3
00A194  2  C8             iny
00A195  2  B1 00          lda (CURRENT_BUFFER_LOCATION),y
00A197  2  85 44          sta FAT16_FAT_NAME+4
00A199  2  C8             iny
00A19A  2  B1 00          lda (CURRENT_BUFFER_LOCATION),y
00A19C  2  85 45          sta FAT16_FAT_NAME+5
00A19E  2  C8             iny
00A19F  2  B1 00          lda (CURRENT_BUFFER_LOCATION),y
00A1A1  2  85 46          sta FAT16_FAT_NAME+6
00A1A3  2  C8             iny
00A1A4  2  B1 00          lda (CURRENT_BUFFER_LOCATION),y
00A1A6  2  85 47          sta FAT16_FAT_NAME+7
00A1A8  2  C8             iny
00A1A9  2  60             rts
00A1AA  2               
00A1AA  2               ; TODO add support for second FAT table
00A1AA  2               read_file_allocation_table:
00A1AA  2                 ; Start (2048) + # of Reserved Sectors (4)
00A1AA  2                 ; primary fat    2052 = 0x100800/512
00A1AA  2                 ; secondary fat  2152 = 0x10D000/512
00A1AA  2                 ; 100 fat tables
00A1AA  2                 ; primary fat    2052 = 0x100800/512
00A1AA  2                 ; 00000000 00000000 00001000 00000100
00A1AA  2  A5 0D          lda FIRST_PARTITION_SECTOR_OFFSET
00A1AC  2  65 18          adc FAT16_RESERVED_SECTORS
00A1AE  2  85 4A          sta zp_sd_currentsector
00A1B0  2  A5 0E          lda FIRST_PARTITION_SECTOR_OFFSET+1
00A1B2  2  65 19          adc FAT16_RESERVED_SECTORS+1
00A1B4  2  85 4B          sta zp_sd_currentsector+1
00A1B6  2  A5 0F          lda FIRST_PARTITION_SECTOR_OFFSET+2
00A1B8  2  85 4C          sta zp_sd_currentsector+2
00A1BA  2  A5 10          lda FIRST_PARTITION_SECTOR_OFFSET+3
00A1BC  2  85 4D          sta zp_sd_currentsector+3
00A1BE  2               _fat_loop:
00A1BE  2                 ; Load a pointer to the data buffer
00A1BE  2  A9 00          lda #<BUFFER
00A1C0  2  85 00          sta CURRENT_BUFFER_LOCATION
00A1C2  2  A9 20          lda #>BUFFER
00A1C4  2  85 01          sta CURRENT_BUFFER_LOCATION+1
00A1C6  2  20 F1 A3       jsr sd_readsector
00A1C9  2  20 D1 A4       jsr newline
00A1CC  2  A5 02          lda SECTOR_INDEX
00A1CE  2  20 BD A4       jsr print_hex
00A1D1  2  20 D1 A4       jsr newline
00A1D4  2  A0 00          ldy #0
00A1D6  2  A2 00          ldx #0
00A1D8  2               print_sector_loop2:
00A1D8  2  B1 00          lda (CURRENT_BUFFER_LOCATION),y
00A1DA  2  20 BD A4       jsr print_hex
00A1DD  2  C8             iny
00A1DE  2  C0 FF          cpy #255
00A1E0  2  D0 F6          bne print_sector_loop2
00A1E2  2  A0 00          ldy #0
00A1E4  2  E6 01          inc CURRENT_BUFFER_LOCATION+1
00A1E6  2  E8             inx
00A1E7  2  E0 02          cpx #2
00A1E9  2  D0 ED          bne print_sector_loop2
00A1EB  2  20 CE A2       jsr inc_zp_sd_currentsector
00A1EE  2  E6 02          inc SECTOR_INDEX
00A1F0  2  A5 02          lda SECTOR_INDEX
00A1F2  2  C9 64          cmp #100
00A1F4  2  D0 C8          bne _fat_loop
00A1F6  2  60             rts
00A1F7  2               
00A1F7  2               
00A1F7  2               read_root_directoy:
00A1F7  2                 ; Root Directory:
00A1F7  2                 ;     2048 + 0x0400 + 0x64 (100) x 2
00A1F7  2                 ;     size: max entries (32) x 512
00A1F7  2  A9 00          lda #0
00A1F9  2  85 02          sta SECTOR_INDEX
00A1FB  2                 ; root dir    2252
00A1FB  2                 ; 00000000 00000000 00001000 11001100
00A1FB  2  A9 CC          lda #204
00A1FD  2  85 4A          sta zp_sd_currentsector
00A1FF  2  A9 08          lda #8
00A201  2  85 4B          sta zp_sd_currentsector+1
00A203  2  A9 00          lda #0
00A205  2  85 4C          sta zp_sd_currentsector+2
00A207  2  85 4D          sta zp_sd_currentsector+3
00A209  2               _root_dir_loop:
00A209  2  A9 00          lda #<BUFFER
00A20B  2  85 00          sta CURRENT_BUFFER_LOCATION
00A20D  2  A9 20          lda #>BUFFER
00A20F  2  85 01          sta CURRENT_BUFFER_LOCATION+1
00A211  2                 ; Read MBR table
00A211  2  20 F1 A3       jsr sd_readsector
00A214  2  20 D1 A4       jsr newline
00A217  2  A5 02          lda SECTOR_INDEX
00A219  2  20 BD A4       jsr print_hex
00A21C  2  20 D1 A4       jsr newline
00A21F  2  A0 00          ldy #0
00A221  2  A2 00          ldx #0
00A223  2               print_sector_loop3:
00A223  2  A9 22          lda #'"'
00A225  2  20 AD A4       jsr print_char
00A228  2                 ; Short file name, len 11
00A228  2  B1 00          lda (CURRENT_BUFFER_LOCATION),y
00A22A  2  20 AD A4       jsr print_char
00A22D  2  C8             iny
00A22E  2  B1 00          lda (CURRENT_BUFFER_LOCATION),y
00A230  2  20 AD A4       jsr print_char
00A233  2  C8             iny
00A234  2  B1 00          lda (CURRENT_BUFFER_LOCATION),y
00A236  2  20 AD A4       jsr print_char
00A239  2  C8             iny
00A23A  2  B1 00          lda (CURRENT_BUFFER_LOCATION),y
00A23C  2  20 AD A4       jsr print_char
00A23F  2  C8             iny
00A240  2  B1 00          lda (CURRENT_BUFFER_LOCATION),y
00A242  2  20 AD A4       jsr print_char
00A245  2  C8             iny
00A246  2  B1 00          lda (CURRENT_BUFFER_LOCATION),y
00A248  2  20 AD A4       jsr print_char
00A24B  2  C8             iny
00A24C  2  B1 00          lda (CURRENT_BUFFER_LOCATION),y
00A24E  2  20 AD A4       jsr print_char
00A251  2  C8             iny
00A252  2  B1 00          lda (CURRENT_BUFFER_LOCATION),y
00A254  2  20 AD A4       jsr print_char
00A257  2  C8             iny
00A258  2  B1 00          lda (CURRENT_BUFFER_LOCATION),y
00A25A  2  20 AD A4       jsr print_char
00A25D  2  C8             iny
00A25E  2  B1 00          lda (CURRENT_BUFFER_LOCATION),y
00A260  2  20 AD A4       jsr print_char
00A263  2  C8             iny
00A264  2  B1 00          lda (CURRENT_BUFFER_LOCATION),y
00A266  2  20 AD A4       jsr print_char
00A269  2  C8             iny
00A26A  2  A9 22          lda #'"'
00A26C  2  20 AD A4       jsr print_char
00A26F  2                 ; FFWD to end of entry
00A26F  2  98             tya
00A270  2  69 0F          adc #15
00A272  2  A8             tay
00A273  2  A9 22          lda #'"'
00A275  2  20 AD A4       jsr print_char
00A278  2                 ; sector and size
00A278  2  B1 00          lda (CURRENT_BUFFER_LOCATION),y
00A27A  2  20 BD A4       jsr print_hex
00A27D  2  C8             iny
00A27E  2  B1 00          lda (CURRENT_BUFFER_LOCATION),y
00A280  2  20 BD A4       jsr print_hex
00A283  2  C8             iny
00A284  2  A9 22            lda #'"'
00A286  2  20 AD A4       jsr print_char
00A289  2  A9 22            lda #'"'
00A28B  2  20 AD A4       jsr print_char
00A28E  2  B1 00          lda (CURRENT_BUFFER_LOCATION),y
00A290  2  20 BD A4       jsr print_hex
00A293  2  C8             iny
00A294  2  B1 00          lda (CURRENT_BUFFER_LOCATION),y
00A296  2  20 BD A4       jsr print_hex
00A299  2  C8             iny
00A29A  2  B1 00          lda (CURRENT_BUFFER_LOCATION),y
00A29C  2  20 BD A4       jsr print_hex
00A29F  2  C8             iny
00A2A0  2  B1 00          lda (CURRENT_BUFFER_LOCATION),y
00A2A2  2  20 BD A4       jsr print_hex
00A2A5  2  C8             iny
00A2A6  2  A9 22          lda #'"'
00A2A8  2  20 AD A4       jsr print_char
00A2AB  2  C0 FF          cpy #255
00A2AD  2  C8             iny
00A2AE  2  F0 03          beq inc_y
00A2B0  2  4C 23 A2       jmp print_sector_loop3
00A2B3  2               inc_y:
00A2B3  2  A0 00          ldy #0
00A2B5  2  E6 01          inc CURRENT_BUFFER_LOCATION+1
00A2B7  2  E8             inx
00A2B8  2  E0 02          cpx #2
00A2BA  2  F0 03          beq next_sector
00A2BC  2  4C 23 A2       jmp print_sector_loop3
00A2BF  2               next_sector:
00A2BF  2  20 CE A2       jsr inc_zp_sd_currentsector
00A2C2  2  E6 02          inc SECTOR_INDEX
00A2C4  2  A5 02          lda SECTOR_INDEX
00A2C6  2  C9 20          cmp #32
00A2C8  2  F0 03          beq exit_loop
00A2CA  2  4C 09 A2       jmp _root_dir_loop
00A2CD  2               exit_loop:
00A2CD  2  60             rts
00A2CE  2               
00A2CE  2               
00A2CE  2               inc_zp_sd_currentsector:
00A2CE  2  E6 4A          inc zp_sd_currentsector
00A2D0  2  D0 0A          bne inc_zp_sd_currentsector_exit
00A2D2  2  E6 4B          inc zp_sd_currentsector+1
00A2D4  2  D0 06          bne inc_zp_sd_currentsector_exit
00A2D6  2  E6 4C          inc zp_sd_currentsector+2
00A2D8  2  D0 02          bne inc_zp_sd_currentsector_exit
00A2DA  2  E6 4D          inc zp_sd_currentsector+3
00A2DC  2               inc_zp_sd_currentsector_exit:
00A2DC  2  60             rts
00A2DD  2               
00A2DD  2               
00A2DD  2               
00A2DD  2                 .include "hwconfig.s"
00A2DD  3               PORTA = $1700
00A2DD  3               DDRA = $1701
00A2DD  3               PORTB = $1702
00A2DD  3               DDRB = $1703
00A2DD  3               
00A2DD  3               PRTBYT = $1E3B
00A2DD  3               
00A2DD  3               SD_CS   = %00010000
00A2DD  3               SD_SCK  = %00001000
00A2DD  3               SD_MOSI = %00000100
00A2DD  3               SD_MISO = %00000010
00A2DD  3               
00A2DD  3               PORTA_OUTPUTPINS = SD_CS | SD_SCK | SD_MOSI
00A2DD  3               
00A2DD  3               via_init:
00A2DD  3  A9 FF          lda #%11111111          ; Set all pins on port B to output
00A2DF  3  8D 03 17       sta DDRB
00A2E2  3  A9 1C          lda #PORTA_OUTPUTPINS   ; Set various pins on port A to output
00A2E4  3  8D 01 17       sta DDRA
00A2E7  3  60             rts
00A2E8  3               
00A2E8  2                 .include "libsd.s"
00A2E8  3               ; SD card interface module
00A2E8  3               ;
00A2E8  3               ; Requires zero-page variable storage:
00A2E8  3               ;   zp_sd_address - 2 bytes
00A2E8  3               ;   zp_sd_currentsector - 4 bytes
00A2E8  3               
00A2E8  3               sd_init:
00A2E8  3  A9 00          lda #0
00A2EA  3  85 4D          sta zp_sd_currentsector+3
00A2EC  3  A9 FF          lda #255
00A2EE  3  85 4C          sta zp_sd_currentsector+2           ; Mark buffer data as invalid
00A2F0  3                 ; Let the SD card boot up, by pumping the clock with SD CS disabled
00A2F0  3               
00A2F0  3                 ; We need to apply around 80 clock pulses with CS and MOSI high.
00A2F0  3                 ; Normally MOSI doesn't matter when CS is high, but the card is
00A2F0  3                 ; not yet is SPI mode, and in this non-SPI state it does care.
00A2F0  3  A0 00          ldy #0
00A2F2  3               _initretry:
00A2F2  3  A9 14          lda #SD_CS | SD_MOSI
00A2F4  3  A2 A0          ldx #160               ; toggle the clock 160 times, so 80 low-high transitions
00A2F6  3               _preinitloop:
00A2F6  3  49 08          eor #SD_SCK
00A2F8  3  8D 00 17       sta PORTA
00A2FB  3  CA             dex
00A2FC  3  D0 F8          bne _preinitloop
00A2FE  3               
00A2FE  3               _cmd0: ; GO_IDLE_STATE - resets card to idle state, and SPI mode
00A2FE  3  A9 65          lda #<sd_cmd0_bytes
00A300  3  85 48          sta zp_sd_address
00A302  3  A9 A3          lda #>sd_cmd0_bytes
00A304  3  85 49          sta zp_sd_address+1
00A306  3               
00A306  3  20 B7 A3       jsr sd_sendcommand
00A309  3               
00A309  3                 ; Expect status response $01 (not initialized)
00A309  3  C9 01          cmp #$01
00A30B  3  D0 4B          bne _initfailed
00A30D  3               
00A30D  3               _cmd8: ; SEND_IF_COND - tell the card how we want it to operate (3.3V, etc)
00A30D  3  A9 6B          lda #<sd_cmd8_bytes
00A30F  3  85 48          sta zp_sd_address
00A311  3  A9 A3          lda #>sd_cmd8_bytes
00A313  3  85 49          sta zp_sd_address+1
00A315  3               
00A315  3  20 B7 A3       jsr sd_sendcommand
00A318  3               
00A318  3                 ; Expect status response $01 (not initialized)
00A318  3  C9 01          cmp #$01
00A31A  3  D0 3C          bne _initfailed
00A31C  3               
00A31C  3                 ; Read 32-bit return value, but ignore it
00A31C  3  20 7D A3       jsr sd_readbyte
00A31F  3  20 7D A3       jsr sd_readbyte
00A322  3  20 7D A3       jsr sd_readbyte
00A325  3  20 7D A3       jsr sd_readbyte
00A328  3               
00A328  3               _cmd55: ; APP_CMD - required prefix for ACMD commands
00A328  3  A9 71          lda #<sd_cmd55_bytes
00A32A  3  85 48          sta zp_sd_address
00A32C  3  A9 A3          lda #>sd_cmd55_bytes
00A32E  3  85 49          sta zp_sd_address+1
00A330  3               
00A330  3  20 B7 A3       jsr sd_sendcommand
00A333  3               
00A333  3                 ; Expect status response $01 (not initialized)
00A333  3  C9 01          cmp #$01
00A335  3  D0 21          bne _initfailed
00A337  3               
00A337  3               _cmd41: ; APP_SEND_OP_COND - send operating conditions, initialize card
00A337  3  A9 77          lda #<sd_cmd41_bytes
00A339  3  85 48          sta zp_sd_address
00A33B  3  A9 A3          lda #>sd_cmd41_bytes
00A33D  3  85 49          sta zp_sd_address+1
00A33F  3               
00A33F  3  20 B7 A3       jsr sd_sendcommand
00A342  3               
00A342  3                 ; Status response $00 means initialised
00A342  3  C9 00          cmp #$00
00A344  3  F0 11          beq _initialized
00A346  3               
00A346  3                 ; Otherwise expect status response $01 (not initialized)
00A346  3  C9 01          cmp #$01
00A348  3  D0 0E          bne _initfailed
00A34A  3               
00A34A  3                 ; Not initialized yet, so wait a while then try again.
00A34A  3                 ; This retry is important, to give the card time to initialize.
00A34A  3               
00A34A  3  A2 00          ldx #0
00A34C  3  A0 00          ldy #0
00A34E  3               _delayloop:
00A34E  3  88             dey
00A34F  3  D0 FD          bne _delayloop
00A351  3  CA             dex
00A352  3  D0 FA          bne _delayloop
00A354  3               
00A354  3  4C 28 A3       jmp _cmd55
00A357  3               
00A357  3               
00A357  3               _initialized:
00A357  3                 ;lda #'Y'
00A357  3                 ;jsr print_char
00A357  3  60             rts
00A358  3               
00A358  3               _initfailed:
00A358  3  C8             iny
00A359  3  C0 02          cpy #2
00A35B  3  D0 95          bne _initretry
00A35D  3  A9 58          lda #'X'
00A35F  3  20 AD A4       jsr print_char
00A362  3               _loop:
00A362  3  4C 62 A3       jmp _loop
00A365  3               
00A365  3               
00A365  3               sd_cmd0_bytes:
00A365  3  40 00 00 00    .byte $40, $00, $00, $00, $00, $95
00A369  3  00 95        
00A36B  3               sd_cmd8_bytes:
00A36B  3  48 00 00 01    .byte $48, $00, $00, $01, $aa, $87
00A36F  3  AA 87        
00A371  3               sd_cmd55_bytes:
00A371  3  77 00 00 00    .byte $77, $00, $00, $00, $00, $01
00A375  3  00 01        
00A377  3               sd_cmd41_bytes:
00A377  3  69 40 00 00    .byte $69, $40, $00, $00, $00, $01
00A37B  3  00 01        
00A37D  3               
00A37D  3               
00A37D  3               
00A37D  3               sd_readbyte:
00A37D  3                 ; Enable the card and tick the clock 8 times with MOSI high,
00A37D  3                 ; capturing bits from MISO and returning them
00A37D  3               
00A37D  3  A2 FE          ldx #$fe    ; Preloaded with seven ones and a zero, so we stop after eight bits
00A37F  3               
00A37F  3               _rbloop:
00A37F  3               
00A37F  3  A9 04          lda #SD_MOSI                ; enable card (CS low), set MOSI (resting state), SCK low
00A381  3  8D 00 17       sta PORTA
00A384  3               
00A384  3  A9 0C          lda #SD_MOSI | SD_SCK       ; toggle the clock high
00A386  3  8D 00 17       sta PORTA
00A389  3               
00A389  3  AD 00 17       lda PORTA                   ; read next bit
00A38C  3  29 02          and #SD_MISO
00A38E  3               
00A38E  3  18             clc                         ; default to clearing the bottom bit
00A38F  3  F0 01          beq _bitnotset              ; unless MISO was set
00A391  3  38             sec                         ; in which case get ready to set the bottom bit
00A392  3               _bitnotset:
00A392  3               
00A392  3  8A             txa                         ; transfer partial result from X
00A393  3  2A             rol                         ; rotate carry bit into read result, and loop bit into carry
00A394  3  AA             tax                         ; save partial result back to X
00A395  3               
00A395  3  B0 E8          bcs _rbloop                   ; loop if we need to read more bits
00A397  3               
00A397  3  60             rts
00A398  3               
00A398  3               
00A398  3               sd_writebyte:
00A398  3                 ; Tick the clock 8 times with descending bits on MOSI
00A398  3                 ; SD communication is mostly half-duplex so we ignore anything it sends back here
00A398  3               
00A398  3  A2 08          ldx #8                      ; send 8 bits
00A39A  3               
00A39A  3               _wbloop:
00A39A  3  0A             asl                         ; shift next bit into carry
00A39B  3  A8             tay                         ; save remaining bits for later
00A39C  3               
00A39C  3  A9 00          lda #0
00A39E  3  90 02          bcc _sendbit                ; if carry clear, don't set MOSI for this bit
00A3A0  3  09 04          ora #SD_MOSI
00A3A2  3               
00A3A2  3               _sendbit:
00A3A2  3  8D 00 17       sta PORTA                   ; set MOSI (or not) first with SCK low
00A3A5  3  49 08          eor #SD_SCK
00A3A7  3  8D 00 17       sta PORTA                   ; raise SCK keeping MOSI the same, to send the bit
00A3AA  3               
00A3AA  3  98             tya                         ; restore remaining bits to send
00A3AB  3               
00A3AB  3  CA             dex
00A3AC  3  D0 EC          bne _wbloop                   ; loop if there are more bits to send
00A3AE  3               
00A3AE  3  60             rts
00A3AF  3               
00A3AF  3               
00A3AF  3               sd_waitresult:
00A3AF  3                 ; Wait for the SD card to return something other than $ff
00A3AF  3  20 7D A3       jsr sd_readbyte
00A3B2  3  C9 FF          cmp #$ff
00A3B4  3  F0 F9          beq sd_waitresult
00A3B6  3  60             rts
00A3B7  3               
00A3B7  3               
00A3B7  3               sd_sendcommand:
00A3B7  3                 ; Debug print which command is being executed
00A3B7  3                 ; lda #'c'
00A3B7  3                 ; jsr print_char
00A3B7  3                 ; ldx #0
00A3B7  3                 ; lda (zp_sd_address,x)
00A3B7  3                 ; jsr print_hex
00A3B7  3               
00A3B7  3  A9 04          lda #SD_MOSI           ; pull CS low to begin command
00A3B9  3  8D 00 17       sta PORTA
00A3BC  3               
00A3BC  3  A0 00          ldy #0
00A3BE  3  B1 48          lda (zp_sd_address),y    ; command byte
00A3C0  3  20 98 A3       jsr sd_writebyte
00A3C3  3  A0 01          ldy #1
00A3C5  3  B1 48          lda (zp_sd_address),y    ; data 1
00A3C7  3  20 98 A3       jsr sd_writebyte
00A3CA  3  A0 02          ldy #2
00A3CC  3  B1 48          lda (zp_sd_address),y    ; data 2
00A3CE  3  20 98 A3       jsr sd_writebyte
00A3D1  3  A0 03          ldy #3
00A3D3  3  B1 48          lda (zp_sd_address),y    ; data 3
00A3D5  3  20 98 A3       jsr sd_writebyte
00A3D8  3  A0 04          ldy #4
00A3DA  3  B1 48          lda (zp_sd_address),y    ; data 4
00A3DC  3  20 98 A3       jsr sd_writebyte
00A3DF  3  A0 05          ldy #5
00A3E1  3  B1 48          lda (zp_sd_address),y    ; crc
00A3E3  3  20 98 A3       jsr sd_writebyte
00A3E6  3               
00A3E6  3  20 AF A3       jsr sd_waitresult
00A3E9  3  48             pha
00A3EA  3               
00A3EA  3                 ; Debug print the result code
00A3EA  3                 ; jsr print_hex
00A3EA  3               
00A3EA  3                 ; End command
00A3EA  3  A9 14          lda #SD_CS | SD_MOSI   ; set CS high again
00A3EC  3  8D 00 17       sta PORTA
00A3EF  3               
00A3EF  3  68             pla   ; restore result code
00A3F0  3  60             rts
00A3F1  3               
00A3F1  3               
00A3F1  3               sd_readsector:
00A3F1  3                 ; Read a sector from the SD card.  A sector is 512 bytes.
00A3F1  3                 ;
00A3F1  3                 ; Parameters:
00A3F1  3                 ;    zp_sd_currentsector   32-bit sector number
00A3F1  3                 ;    zp_sd_address     address of buffer to receive data
00A3F1  3               
00A3F1  3  A9 04          lda #SD_MOSI
00A3F3  3  8D 00 17       sta PORTA
00A3F6  3               
00A3F6  3                 ; Command 17, arg is sector number, crc not checked
00A3F6  3  A9 51          lda #$51                    ; CMD17 - READ_SINGLE_BLOCK
00A3F8  3  20 98 A3       jsr sd_writebyte
00A3FB  3  A5 4D          lda zp_sd_currentsector+3   ; sector 24:31
00A3FD  3  20 98 A3       jsr sd_writebyte
00A400  3  A5 4C          lda zp_sd_currentsector+2   ; sector 16:23
00A402  3  20 98 A3       jsr sd_writebyte
00A405  3  A5 4B          lda zp_sd_currentsector+1   ; sector 8:15
00A407  3  20 98 A3       jsr sd_writebyte
00A40A  3  A5 4A          lda zp_sd_currentsector     ; sector 0:7
00A40C  3  20 98 A3       jsr sd_writebyte
00A40F  3  A9 01          lda #$01                    ; crc (not checked)
00A411  3  20 98 A3       jsr sd_writebyte
00A414  3               
00A414  3  20 AF A3       jsr sd_waitresult
00A417  3  C9 00          cmp #$00
00A419  3  D0 22          bne _libsdfail
00A41B  3               
00A41B  3                 ; wait for data
00A41B  3  20 AF A3       jsr sd_waitresult
00A41E  3  C9 FE          cmp #$fe
00A420  3  D0 1B          bne _libsdfail
00A422  3               
00A422  3                 ; Need to read 512 bytes - two pages of 256 bytes each
00A422  3  20 32 A4       jsr _readpage
00A425  3  E6 49          inc zp_sd_address+1
00A427  3  20 32 A4       jsr _readpage
00A42A  3  C6 49          dec zp_sd_address+1
00A42C  3               
00A42C  3                 ; End command
00A42C  3  A9 14          lda #SD_CS | SD_MOSI
00A42E  3  8D 00 17       sta PORTA
00A431  3               
00A431  3  60             rts
00A432  3               
00A432  3               _readpage:
00A432  3                 ; Read 256 bytes to the address at zp_sd_address
00A432  3  A0 00          ldy #0
00A434  3               _readpageloop:
00A434  3  20 7D A3       jsr sd_readbyte
00A437  3  91 48          sta (zp_sd_address),y
00A439  3  C8             iny
00A43A  3  D0 F8          bne _readpageloop
00A43C  3  60             rts
00A43D  3               
00A43D  3               _libsdfail:
00A43D  3  A9 73          lda #'s'
00A43F  3  20 AD A4       jsr print_char
00A442  3  A9 3A          lda #':'
00A444  3  20 AD A4       jsr print_char
00A447  3  A9 66          lda #'f'
00A449  3  20 AD A4       jsr print_char
00A44C  3               _libsdfailloop:
00A44C  3  4C 4C A4       jmp _libsdfailloop
00A44F  3               
00A44F  3               sd_writesector:
00A44F  3                 ; Write a sector to the SD card.  A sector is 512 bytes.
00A44F  3                 ;
00A44F  3                 ; Parameters:
00A44F  3                 ;    zp_sd_currentsector   32-bit sector number
00A44F  3                 ;    zp_sd_address     address of buffer to take data from
00A44F  3               
00A44F  3  A9 04          lda #SD_MOSI
00A451  3  8D 00 17       sta PORTA
00A454  3               
00A454  3                 ; Command 24, arg is sector number, crc not checked
00A454  3  A9 58          lda #$58                    ; CMD24 - WRITE_BLOCK
00A456  3  20 98 A3       jsr sd_writebyte
00A459  3  A5 4D          lda zp_sd_currentsector+3   ; sector 24:31
00A45B  3  20 98 A3       jsr sd_writebyte
00A45E  3  A5 4C          lda zp_sd_currentsector+2   ; sector 16:23
00A460  3  20 98 A3       jsr sd_writebyte
00A463  3  A5 4B          lda zp_sd_currentsector+1   ; sector 8:15
00A465  3  20 98 A3       jsr sd_writebyte
00A468  3  A5 4A          lda zp_sd_currentsector     ; sector 0:7
00A46A  3  20 98 A3       jsr sd_writebyte
00A46D  3  A9 01          lda #$01                    ; crc (not checked)
00A46F  3  20 98 A3       jsr sd_writebyte
00A472  3               
00A472  3  20 AF A3       jsr sd_waitresult
00A475  3  C9 00          cmp #$00
00A477  3  D0 C4          bne _libsdfail
00A479  3               
00A479  3                 ; Send start token
00A479  3  A9 FE          lda #$fe
00A47B  3  20 98 A3       jsr sd_writebyte
00A47E  3               
00A47E  3                 ; Need to write 512 bytes - two pages of 256 bytes each
00A47E  3  20 9E A4       jsr _writepage
00A481  3  E6 49          inc zp_sd_address+1
00A483  3  20 9E A4       jsr _writepage
00A486  3  C6 49          dec zp_sd_address+1
00A488  3               
00A488  3                 ; wait for data response
00A488  3  20 AF A3       jsr sd_waitresult
00A48B  3  29 1F          and #$1f
00A48D  3  C9 05          cmp #$05
00A48F  3  D0 AC          bne _libsdfail
00A491  3               
00A491  3               _waitidle:
00A491  3  20 7D A3       jsr sd_readbyte
00A494  3  C9 FF          cmp #$ff
00A496  3  D0 F9          bne _waitidle
00A498  3               
00A498  3                 ; End command
00A498  3  A9 14          lda #SD_CS | SD_MOSI ; set cs and mosi high (disconnected)
00A49A  3  8D 00 17       sta PORTA
00A49D  3               
00A49D  3  60             rts
00A49E  3               
00A49E  3               _writepage:
00A49E  3                 ; Write 256 bytes fom zp_sd_address
00A49E  3  A0 00          ldy #0
00A4A0  3               _writeloop:
00A4A0  3  98             tya ; transfer counter to a register
00A4A1  3  48             pha ; push counter to stack
00A4A2  3  B1 48          lda (zp_sd_address),y
00A4A4  3  20 98 A3       jsr sd_writebyte
00A4A7  3  68             pla ; pull counter from stack
00A4A8  3  A8             tay ; transfer back
00A4A9  3  C8             iny
00A4AA  3  D0 F4          bne _writeloop
00A4AC  3  60             rts
00A4AD  3               
00A4AD  2                 .include "libio.s"
00A4AD  3               ; Save A, X, and Y during destructive operations
00A4AD  3               SAVE_A = $100               ; 1 bytes
00A4AD  3               SAVE_X = $101               ; 1 bytes
00A4AD  3               SAVE_Y = $102               ; 1 byte
00A4AD  3               
00A4AD  3               
00A4AD  3               print_char:
00A4AD  3               ; JSR OUTCH    1EA0     Print ASCII char  A     -       Xis preserved
00A4AD  3               ;                       in A on TTY                     Y = FF
00A4AD  3               ;                                                       A = FF
00A4AD  3  8D 00 01       sta SAVE_A
00A4B0  3  8C 02 01       sty SAVE_Y
00A4B3  3  20 A0 1E       jsr OUTCH
00A4B6  3  AC 02 01       ldy SAVE_Y
00A4B9  3  AD 00 01       lda SAVE_A
00A4BC  3  60             rts
00A4BD  3               
00A4BD  3               print_hex:
00A4BD  3               ; JSR PRTBYT   1E3B     Prints A as       A     -       A preserved
00A4BD  3               ;                       2 Hex Char.                     X preserved
00A4BD  3               ;                                                       Y = FF
00A4BD  3  8C 02 01       sty SAVE_Y
00A4C0  3  20 3B 1E       jsr PRTBYT
00A4C3  3  AC 02 01       ldy SAVE_Y
00A4C6  3  60             rts
00A4C7  3               
00A4C7  3               get_char:
00A4C7  3               ; JSR GETCH    1E5A     Put character     -     A       X preserved
00A4C7  3               ;                       from TTY in A                   Y = FF
00A4C7  3  8C 02 01       sty SAVE_Y
00A4CA  3  20 5A 1E       jsr GETCH
00A4CD  3  AC 00 01       ldy SAVE_A
00A4D0  3  60             rts
00A4D1  3               
00A4D1  3               newline:
00A4D1  3  A9 0D          lda #$0D                        ; CR
00A4D3  3  20 AD A4       jsr print_char                  ; Send a carriage retuen
00A4D6  3  A9 0A          lda #$0A                        ; LF
00A4D8  3  20 AD A4       jsr print_char                  ; Send the line feed
00A4DB  3  60             rts
00A4DC  3               
00A4DC  3               clearscreen:
00A4DC  3  A2 00          ldx #0
00A4DE  3               clearscreenloop:
00A4DE  3  20 D1 A4       jsr newline
00A4E1  3  E8             inx
00A4E2  3  E0 19          cpx #25
00A4E4  3  D0 F8          bne clearscreenloop
00A4E6  3  60             rts
00A4E7  3               
00A4E7  2               
00A4E7  1               
